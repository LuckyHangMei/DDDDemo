### 3、实体与值对象的区别：

1. 实体拥有标识，而值对象没有。
2. 相等性测试方式不同。实体根据标识判等，而值对象根据内部所有属性值判等。
3. 实体允许变化，值对象不允许变化。
4. 持久化的映射方式不同。实体采用单表继承、类表继承和具体表继承来映射类层次结构，而值对象使用嵌入值或序列化大对象方式映射。



### 针对值对象不可变，实体可变的解释

这个实体可变是指有了ID后，是字段内容就可以改变吧？还是说结构可以改变？而值对象不可变应该是没有ID，不能直接修改字段内容，要修改你只能通过student的去修改？

**5、聚合中的实体和值对象应该具有相同的生命周期，并应该属于一个业务场景。**

 

比如一个最常见的问题：论坛发帖和回复如何将里聚合模型，大家想到这里，联想到上边的订单和订单详情，肯定会peng peng的这样定义；

![img](https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181106170934289-120901748.png)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
    /// <summary>
    /// 聚合根 发帖
    /// </summary>
    public class Post : AggregateRoot
    {
        public string PostTitle;
        public List<Reply> Reply;//回复
        //...
    }
    /// <summary>
    /// 实体 回复
    /// </summary>
    public class Reply : Entity
    {
        public string Content;
        //...
    }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

这样初看是没有什么问题，很正常呀，发帖子是发回复的聚合根，回复必须有一个帖子，不然无效，看似合理的地方却有不合理。

比如，当我要对一个帖子发表回复时，我取出当前帖子信息，嗯，这个很对，但是，如果我对回复进行回复的时候，那就不好了，我每次还是都要取出整个带有很多回复的帖子，然后往里面增加回复，然后保存整个帖子，因为聚合的一致性要求我们必须这么做。无论是在场景还是在并发的情况下这是不行的。

如果帖子和回复在一个聚合内，聚合意味着“修改数据的一个最小单元”，聚合内的所有对象要看成是一个整体最小单元进行保存。这么要求是因为聚合的意义是维护聚合内的不变性，数据一致性；
仔细分析我们会发现帖子和回复之间没有数据一致性要求。所以不需要设计在同一个聚合内。

从场景的角度，我们有发表帖子，发表回复，这两个不同的场景，发表帖子创建的是帖子，而发表回复创建的是回复。但是订单就不一样，我们有创建订单，修改订单这两个场景。这两个场景都是围绕这订单这个聚合展开的。

所以我们应该把回复实体也单独作为一个聚合根来处理：

![img](https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181106171952131-1427193675.png)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
    /// <summary>
    /// 内容
    /// </summary>
    public class Content
    {
        public string Id;
        public DateTime DatePost;
        public string Contents;
        public string Title;
        //...
    }
    /// <summary>
    /// 聚合根 发帖
    /// </summary>
    public class Post : AggregateRoot,ContentBase
    {
        public string Title;
        //...
    }
    /// <summary>
    /// 聚合根 回复
    /// </summary>
    public class Reply : AggregateRoot,ContentBase
    {
        public Content Content;
        public Post Post;//帖子实体聚合根
        //...
    }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 当然这样的话，我们就不能通过帖子一次性全部把回复拿出来，我们就只能单写逻辑了，比如在应用层，但是这样不会对领域层造成失血，因为本来就不是领域的问题。

 

# 二、聚合是如何联系的

如何联系，在上文的代码中以及由体现了，这里用文字来说明下，具体的可以参考文中的代码

### 1、聚合根、实体、值对象的区别？

**从标识的角度：**

聚合根具有全局的唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象没有唯一标识，不存在这个值对象或那个值对象的说法；

**从是否只读的角度：**

聚合根除了唯一标识外，其他所有状态信息都理论上可变；实体是可变的；值对象是只读的；

**从生命周期的角度：**

聚合根有独立的生命周期，实体的生命周期从属于其所属的聚合，实体完全由其所属的聚合根负责管理维护；值对象无生命周期可言，因为只是一个值；

### 2、聚合根、实体、值对象对象之间如何建立关联？

聚合根到聚合根：通过ID关联；

聚合根到其内部的实体，直接对象引用；

聚合根到值对象，直接对象引用；

实体对其他对象的引用规则：1）能引用其所属聚合内的聚合根、实体、值对象；2）能引用外部聚合根，但推荐以ID的方式关联，另外也可以关联某个外部聚合内的实体，但必须是ID关联，否则就出现同一个实体的引用被两个聚合根持有，这是不允许的，一个实体的引用只能被其所属的聚合根持有；

值对象对其他对象的引用规则：只需确保值对象是只读的即可，推荐值对象的所有属性都尽量是值对象；

### 3、如何识别聚合与聚合根？

明确含义：一个Bounded Context（界定的上下文）可能包含多个聚合，每个聚合都有一个根实体，叫做聚合根；

识别顺序：先找出哪些实体可能是聚合根，再逐个分析每个聚合根的边界，即该聚合根应该聚合哪些实体或值对象；最后再划分Bounded Context；

聚合边界确定法则：根据不变性约束规则（Invariant）。不变性规则有两类：1）聚合边界内必须具有哪些信息，如果没有这些信息就不能称为一个有效的聚合；2）聚合内的某些对象的状态必须满足某个业务规则；

1.一个聚合只有一个聚合根，聚合根是可以独立存在的，聚合中其他实体或值对象依赖与聚合根。

2.只有聚合根才能被外部访问到，聚合根维护聚合的内部一致性。

 

# 三、聚合的一些思考

### 1、优点

其实整篇文章都是在说的聚合的优点，这里简单再概况下：

 聚合的出现，很大程度上，帮助了DDD领域驱动设计的全部普及，试想一下，如果没有聚合和聚合根的思维，单单来说DDD，总感觉不是很舒服，而且领域驱动设计所分的子领域和限界上下文都是从更高的一个层面上来区分的，有的项目甚至只有一个限界上下文，那么，聚合的思考和使用，就特别的高效，且有必要。

 聚合设计的原则应该是聚合内各个有相互关联的对象之间要保持 **不变性**！我们平时设计聚合时，一般只考虑到了对象之间的关系，比如看其是否能独立存在，是否必须依赖与某个其他对象而存在。

 

### 2、担忧

我接触的DDD中的聚合根的分析设计思路大致是这样：1、业务本质逻辑分析；2、确认聚合对象间的组成关系；3、所有的读写必须沿着这些固有的路径进行。
这是一种静态聚合的设计思路。理论上讲，似乎没有什么问题。但实际上，因为每一个人的思路以及学习能力，甚至是专业领域知识的不同，会导致设计的不合理，特别是按照这个正确的路线设计，如果有偏差，就会达到不同的效果，有时候会事倍功半，反而把罪过强加到DDD领域驱动上，或者增加到聚合上，这也就是大家一直不想去更深层去研究实践这种思想的原因。

 DDD本来就是处理复杂业务逻辑设计问题。我看到大家用DDD去分析一些小项目的时候，**往往为谁是聚合根而无法达成共识**。**这说明每个人对业务认识的角度、深度和广度都不同，自然得出的聚合根也不同。**试想，这样的情况下，领域模型怎么保持稳定。

不过这也许不是一个大问题，只要我们用心去经营，去学习，去沟通，一切都不是问题！



# 四、CQRS 读写分离初探

 从上边的问题中，我们发现，在DDD领域驱动设计中，我们是一起以领域模型为核心的，这个时候出现了几个概念：

### 1、DDD中四种模型

如果你是从我的系列的第一篇开始读，你应该已经对这两个模型很熟悉了，领域模型，视图模型，当然，还有咱们一直开发中使用到的数据模型，那第四个是什么呢？

1. 数据模型：面向持久化，数据的载体。
2. 领域模型：面向业务，行为的载体。
3. 视图模型：面向UI（向外），数据的载体。
4. 命令模型：面向UI（向内），数据的载体。

这个命令模型Command，就是解决了我们的 视图模型到领域模型中，出现污染的问题。其他 命令模型，就和我们的领域模型、视图模型是一样的，也是一个数据载体，这不过它可以配和着事件，进行复杂的操作控制，这个以后会慢慢说到。



### 2、传统 CURD 命令有哪些问题

> 1、使用同一个对象实体来进行数据库读写可能会太粗糙，大多数情况下，比如编辑的时候可能只需要更新个别字段，但是却需要将整个对象都穿进去，有些字段其实是不需要更新的。在查询的时候在表现层可能只需要个别字段，但是需要查询和返回整个实体对象。
>
> 2、使用同一实体对象对同一数据进行读写操作的时候，可能会遇到资源竞争的情况，经常要处理的锁的问题，在写入数据的时候，需要加锁。读取数据的时候需要判断是否允许脏读。这样使得系统的逻辑性和复杂性增加，并且会对系统吞吐量的增长会产生影响。
>
> 3、同步的，直接与数据库进行交互在大数据量同时访问的情况下可能会影响性能和响应性，并且可能会产生性能瓶颈。
>
> 4、由于同一实体对象都会在读写操作中用到，所以对于安全和权限的管理会变得比较复杂。